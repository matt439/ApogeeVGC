# Object Instance Flow: Before and After Fix

## BEFORE FIX (Two BattleGame Instances - BROKEN)

```
User Code              Simulator             PlayerGui    BattleGame
??????????????????????????????????????????????????????????????????????????????????????????

game = new BattleGame()
  ?
  ?? Instance #1 Created
  ?    _choiceInputManager = null
  ?    LoadContent not yet called
  ?
options.GuiWindow = game ???????????????????????????????????????????????????> Instance #1
  ?
game.StartBattle(
  library,
  options,  ?????????????> CreateGuiPlayer(options)
  simulator)   ?
  ?       ?
  ?        new PlayerGui(sideId, options, this)
  ?          ?
  ?      ?? Constructor runs:
  ?       ?    GuiWindow = new() ???????????????????????> Instance #2
  ?     ?            NEW BattleGame Created!
  ? ?          _choiceInputManager = null
  ?           ? LoadContent not called
  ?            ?
  ?         ?? playerGui.GuiWindow = options.GuiWindow
  ?  ?    (tries to set but Instance #2 already set)
  ?      ?
  ?    ?? Returns PlayerGui with GuiWindow = Instance #2 ?
  ?
game.Run()
  ?
  ?? Instance #1.Initialize()
  ?? Instance #1.LoadContent()
  ?    _choiceInputManager = new ChoiceInputManager() ?
  ?
  ?? Instance #1.Update()  (game loop starts)
  ?? Instance #1.Draw()
  ?
  ?? (Instance #1 is the REAL running game)


Meanwhile, Battle Thread:
??????????????????????????????????????????????????????????????????????????????
Battle.StartAsync()
  ?
  ?? RequestAndWaitForChoicesAsync()
       ?
       ?? PlayerController.RequestChoiceAsync()
    ?
     ?? PlayerGui.GetNextChoiceAsync()
         ?
              ?? GuiWindow.RequestChoiceAsync() ???????????????> Instance #2
           ?    Goes to WRONG instance!
             ?
            ?? if (_choiceInputManager == null)  ? TRUE!
         throw InvalidOperationException ? CRASH!


Result: Two separate BattleGame instances exist
  Instance #1: Running the game loop, has initialized _choiceInputManager ?
  Instance #2: Orphaned, never initialized, _choiceInputManager is NULL ?
```

---

## AFTER FIX (Single BattleGame Instance - WORKING)

```
User Code     Simulator                    PlayerGui  BattleGame
??????????????????????????????????????????????????????????????????????????????????????????

game = new BattleGame()
  ?
  ?? Instance #1 Created
  ?    _choiceInputManager = null
  ?    LoadContent not yet called
  ?
options.GuiWindow = game ???????????????????????????????????????????????????> Instance #1
  ?
game.StartBattle(
  library,
  options,  ?????????????> CreateGuiPlayer(options)
  simulator)     ?
  ?          ?
  ?     new PlayerGui(sideId, options, this)
  ?       ?
  ?          ?? Constructor runs:
  ?    GuiWindow = options.GuiWindow ?? new()
  ?   GuiWindow = options.GuiWindow ????????????> Instance #1 ?
  ?     (Uses the SAME instance passed in!)
  ?
game.Run()
  ?
  ?? Instance #1.Initialize()
  ?? Instance #1.LoadContent()
  ?    _choiceInputManager = new ChoiceInputManager() ?
  ?
  ?? Instance #1.Update()  (game loop starts)
  ?? Instance #1.Draw()
  ?
  ?? (Instance #1 is the running game)


Meanwhile, Battle Thread:
??????????????????????????????????????????????????????????????????????????????
Battle.StartAsync()
  ?
  ?? RequestAndWaitForChoicesAsync()
       ?
       ?? PlayerController.RequestChoiceAsync()
    ?
            ?? PlayerGui.GetNextChoiceAsync()
           ?
            ?? GuiWindow.RequestChoiceAsync() ???????????????> Instance #1 ?
      ?      Goes to CORRECT instance!
           ?
 ?? if (_choiceInputManager == null)  ? FALSE ?
     return _choiceInputManager
         .RequestChoiceAsync(...) ? SUCCESS!


Result: Single BattleGame instance
  Instance #1: Running the game loop AND handling choice requests ?
  No orphaned instances ?
```

---

## Key Difference

### Before: Property Initializer

```csharp
public class PlayerGui(...) : IPlayer
{
    public BattleGame GuiWindow { get; set; } = new(); // ? Always creates new instance
}
```

**Problem**: The `= new()` runs during construction and **always** creates Instance #2, regardless of what's in `options.GuiWindow`.

### After: Constructor Assignment

```csharp
public class PlayerGui : IPlayer
{
    public BattleGame GuiWindow { get; set; }
  
    public PlayerGui(SideId sideId, PlayerOptions options, IBattleController battleController)
    {
  // ...
        GuiWindow = options.GuiWindow ?? new BattleGame(); // ? Uses provided instance
    }
}
```

**Solution**: The constructor explicitly checks `options.GuiWindow` and uses it if provided, only creating a new instance as a fallback.

---

## Instance Lifecycle Comparison

### BEFORE (Broken)

```
Time   Instance #1 (User's game)       Instance #2 (Orphan)
?????????????????????????????????????????????????????????????????????
  0    new BattleGame()     
  1    Passed to options.GuiWindow     
  2  new BattleGame() (in property initializer)
  3          Assigned to PlayerGui.GuiWindow ?
  4  game.Run() starts      
  5    LoadContent() called     LoadContent() NEVER called
  6    _choiceInputManager ?  _choiceInputManager = null ?
  7    Update/Draw loop running        (unused orphan object)
  8    Battle requests choice          
  9        RequestChoiceAsync() called on orphan
 10               ? CRASH - null reference
```

### AFTER (Fixed)

```
Time   Instance #1 (The ONLY instance)
??????????????????????????????????????????????
  0    new BattleGame()
  1    Passed to options.GuiWindow
  2    Assigned to PlayerGui.GuiWindow ?
  3    game.Run() starts
  4    LoadContent() called
  5    _choiceInputManager ?
  6    Update/Draw loop running
  7    Battle requests choice
  8 RequestChoiceAsync() called
  9    ? SUCCESS - returns initialized manager
```

No orphan instance created! ?
